import socket
import struct
import sys
import os

# Try to import yaml
try:
    import yaml
    HAS_YAML = True
except ImportError:
    HAS_YAML = False

# ==========================================
# CONFIGURATION
# ==========================================
CAN_INTERFACE = "can1"
NODE_ID = 5
COB_ID = 0x180 + NODE_ID  # 0x185
FACTORY_RESOLUTION_MM = 0.025

def get_live_position():
    """Opens a raw socket and waits for one message from the encoder."""
    try:
        sock = socket.socket(socket.PF_CAN, socket.SOCK_RAW, socket.CAN_RAW)
        sock.bind((CAN_INTERFACE,))
    except OSError:
        print(f"ERROR: Could not bind to {CAN_INTERFACE}. Is the interface UP?")
        sys.exit(1)

    print(f"Reading {CAN_INTERFACE} (ID {hex(COB_ID)})...")
    
    while True:
        frame = sock.recv(16)
        can_id, can_dlc, data = struct.unpack("=IB3x8s", frame)
        can_id &= 0x1FFFFFFF

        if can_id == COB_ID:
            raw_ticks = struct.unpack('<I', data[:4])[0]
            sock.close()
            return raw_ticks

def save_config(zero_ticks, mech_max_ticks, mech_height, safe_max_height, direction):
    # 1. Determine the path relative to THIS script
    script_dir = os.path.dirname(os.path.abspath(__file__))
    # UPDATED: Filename is now encoder-config.yaml
    config_path = os.path.join(script_dir, "../config/encoder-config.yaml")
    config_path = os.path.normpath(config_path)

    config_data = {
        "encoder_config": {
            "calibration": {
                "description": "Auto-generated by encoder_calibration.py",
                "resolution_mm_per_tick": FACTORY_RESOLUTION_MM,
                "zero_point_ticks": zero_ticks,
                "mechanical_max_ticks": mech_max_ticks,
                "direction_scalar": direction,
                "mechanical_max_height_mm": round(mech_height, 2)
            },
            "safety": {
                # THIS is the user-defined limit
                "max_allowed_height_mm": round(safe_max_height, 2),
                "min_allowed_height_mm": -10.0
            }
        }
    }

    print(f"\n[INFO] Saving to: {config_path}")

    if HAS_YAML:
        with open(config_path, "w") as f:
            yaml.dump(config_data, f, default_flow_style=False)
        print("[SUCCESS] Config updated.")
    else:
        with open(config_path, "w") as f:
            f.write(str(config_data))
        print("[SUCCESS] Config updated (Text format).")

def main():
    print("=========================================")
    print("   ENCODER LIMIT TEACHING TOOL           ")
    print(f"   Assuming Resolution: {FACTORY_RESOLUTION_MM} mm/tick")
    print("=========================================")
    
    while True:
        # STEP 1: BOTTOM (Zero)
        print("\n[STEP 1] Move lift to the MECHANICAL BOTTOM (Zero).")
        input("Press ENTER to capture > ")
        ticks_low = get_live_position()
        print(f"Captured LOW: {ticks_low} ticks")

        # STEP 2: TOP (Mechanical Max)
        print("\n[STEP 2] Move lift to the MECHANICAL TOP (Physical Limit).")
        input("Press ENTER to capture > ")
        ticks_high = get_live_position()
        print(f"Captured HIGH: {ticks_high} ticks")

        # CALCULATE
        delta_ticks = ticks_high - ticks_low
        
        # Detect Reversal
        if delta_ticks < 0:
            direction = -1
            print("\n[INFO] Detected Reverse Mounting.")
        else:
            direction = 1
            print("\n[INFO] Detected Standard Mounting.")

        # Calculate Mechanical Height
        total_travel_ticks = abs(delta_ticks)
        mech_height_mm = total_travel_ticks * FACTORY_RESOLUTION_MM
        
        print("\n-----------------------------------------")
        print(f"  Mechanical Height: {mech_height_mm:.1f} mm ({mech_height_mm/1000:.2f} m)")
        print("-----------------------------------------")

        # STEP 3: USER INPUT FOR SAFETY LIMIT
        print(f"\n[STEP 3] Set Safety Limit.")
        print(f"The physical max is {mech_height_mm:.1f} mm.")
        try:
            safe_max_input = input(f"Enter MAX ALLOWED HEIGHT in mm (e.g., {mech_height_mm - 50:.1f}) > ")
            safe_max_mm = float(safe_max_input)
        except ValueError:
            print("Invalid number. Using mechanical max as safe max.")
            safe_max_mm = mech_height_mm

        confirm = input(f"Save Safe Max: {safe_max_mm} mm? (y/n/retry) > ").lower()
        if confirm == 'y':
            save_config(ticks_low, ticks_high, mech_height_mm, safe_max_mm, direction)
            break
        elif confirm == 'retry':
            continue
        else:
            print("Aborted.")
            break

if __name__ == "__main__":
    main()
